<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<link rel="stylesheet" href="stylesheet.css" type="text/css"/>
	</head>
<body>
<div id="container">
<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div>
<div id="main">
	<div id="navigation">
		<h2>Modules</h2>
			<ul><li>
				<a href="index.html">index</a>
			</li></ul>
		<ul>
					<li><a href="bit.html">bit</a></li>
					<li><a href="colors.html">colors</a></li>
					<li><a href="colours.html">colours</a></li>
					<li><a href="coroutine.html">coroutine</a></li>
					<li><a href="disk.html">disk</a></li>
					<li><a href="fs.html">fs</a></li>
					<li><a href="global.html">global</a></li>
					<li><a href="gps.html">gps</a></li>
					<li><a href="help.html">help</a></li>
					<li><a href="http.html">http</a></li>
					<li><a href="io.html">io</a></li>
					<li><a href="keys.html">keys</a></li>
					<li><a href="math.html">math</a></li>
					<li><a href="os.html">os</a></li>
					<li><a href="paintutils.html">paintutils</a></li>
					<li><a href="parallel.html">parallel</a></li>
					<li><a href="peripheral.html">peripheral</a></li>
					<li><a href="rednet.html">rednet</a></li>
					<li><a href="redstone.html">redstone</a></li>
					<li><a href="rs.html">rs</a></li>
					<li><a href="shell.html">shell</a></li>
					<li>string</li>
					<li><a href="table.html">table</a></li>
					<li><a href="term.html">term</a></li>
					<li><a href="textutils.html">textutils</a></li>
					<li><a href="turtle.html">turtle</a></li>
					<li><a href="vector.html">vector</a></li>
		</ul>
	</div>
	<div id="content">
   <h1>Module <code>string</code></h1>
   
<h2>String API</h2>
<p>The <a href="http://www.lua.org/manual/5.1/manual.html#5.4">string API</a> provides 
generic functions for <code>string</code> manipulation, such as finding and extracting
substrings, and pattern matching.</p>

   
<h3>Notes:</h3>
<blockquote>
    
    <ol>
        <li><p>When indexing a <code>string</code> in Lua, the first character is at position <code>1</code>
        (not at <code>0</code>, as in C). 
        Indices are allowed to be negative and are interpreted as indexing backwards,
        from the end of the <code>string</code>. Thus, the last character is at position -1, and
        so on.</p></li>
        <li><p>The string library provides all its functions inside the <code>table</code> string.
        It also sets a metatable for <code>strings</code> where the __index field points to the 
        string table. Therefore, you can use the <code>string</code> functions in 
        object-oriented style.
        For instance, <code>string.byte(s, i)</code> can be written as <code>s:byte(i)</code>.</p></li>
        <li><p>The string library assumes one-byte character encodings.</p></li>
    </ol>
</blockquote>

	<h2><a id="#(string)" >Type <code>string</code></a></h2>
		<table class="function_list">
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).byte">string.byte(s, i, j)</a></td>
		<td class="summary">
<p>Returns the internal numerical codes of the characters <code>s[i]</code>, <code>s[i+1]</code>,
..., <code>s[j]</code>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).char">string.char(...)</a></td>
		<td class="summary">
<p>Receives zero or more integers.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).dump">string.dump(f)</a></td>
		<td class="summary">
<p>Returns a <code>string</code> containing a binary representation of the given
<code>function</code>, so that a later <code>loadstring</code> on this <code>string</code> returns a copy of
the <code>function</code>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).find">string.find(s, pattern, init, plain)</a></td>
		<td class="summary">
<p>Looks for the first match of <code>pattern</code> in the <code>string</code> <code>s</code>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).format">string.format(formatstring, ...)</a></td>
		<td class="summary">
<p>Returns a formatted version of its variable number of arguments following
the description given in its first argument (which must be a <code>string</code>).</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).gmatch">string.gmatch(s, pattern)</a></td>
		<td class="summary">
<p>Returns an iterator function that, each time it is called, returns the
next captures from <code>pattern</code> over <code>string</code> <code>s</code>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).gsub">string.gsub(s, pattern, repl, n)</a></td>
		<td class="summary">
<p>Returns a copy of <code>s</code> in which all (or the first <code>n</code>, if given)
occurrences of the <code>pattern</code> have been replaced by a replacement <code>string</code>
specified by <code>repl</code>, which can be a <code>string</code>, a <code>table</code>, or a <code>function</code>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).len">string.len(s)</a></td>
		<td class="summary">
<p>Receives a <code>string</code> and returns its length.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).lower">string.lower(s)</a></td>
		<td class="summary">
<p>Receives a <code>string</code> and returns a copy of this <code>string</code> with all uppercase
letters changed to lowercase.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).match">string.match(s, pattern, init)</a></td>
		<td class="summary">
<p>Looks for the first <em>match</em> of <code>pattern</code> in the <code>string</code> <code>s</code>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).rep">string.rep(s, n)</a></td>
		<td class="summary">
<p>Returns a <code>string</code> that is the concatenation of <code>n</code> copies of the <code>string</code> <code>s</code>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).reverse">string.reverse(s)</a></td>
		<td class="summary">
<p>Returns a <code>string</code> that is the <code>string</code> <code>s</code> reversed.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).sub">string.sub(s, i, j)</a></td>
		<td class="summary">
<p>Returns the substring of <code>s</code> that starts at <code>i</code> and continues until
<code>j</code>; <code>i</code> and <code>j</code> can be negative.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(string).upper">string.upper(s)</a></td>
		<td class="summary">
<p>Receives a <code>string</code> and returns a copy of this <code>string</code> with all lowercase
letters changed to uppercase.</p>
</td>
		</tr>
	</table>

	<h2><a id="#(string)" >Type <code>string</code></a></h2>
		<h3>Field(s)</h3>
		<dl class="function">
<dt>
<a id="#(string).byte" >
<strong>string.byte(s, i, j)</strong>
</a>
</dt>
<dd>
	
<p>Returns the internal numerical codes of the characters <code>s[i]</code>, <code>s[i+1]</code>,
..., <code>s[j]</code>.</p>

	
<p>The default value for <code>i</code> is <code>1</code>; the default value for <code>j</code>
is <code>i</code>.</p>
<h3>Notes:</h3>
<blockquote>
    
    <ol>
        <li>The numerical codes are not necessarily portable across platforms.</li>
    </ol>
</blockquote>

		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
<code>string</code> to handle.</p>

				</li>
				<li>
				
<p><code><em>#number i </em></code>: 
start index, default value is <code>1</code>.</p>

				</li>
				<li>
				
<p><code><em>#number j </em></code>: 
end index, default value is <code>i</code>.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em><a href="##(Untyped)">#Untyped</a>:</em>
the internal numerical codes of the characters <code>s[i]</code>, <code>s[i+1]</code>,..., <code>s[j]</code></p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).char" >
<strong>string.char(...)</strong>
</a>
</dt>
<dd>
	
<p>Receives zero or more integers.</p>

	
<p>Returns a <code>string</code> with length equal to
the number of arguments, in which each character has the internal numerical
code equal to its corresponding argument.</p>
<h3>Notes:</h3>
<blockquote>
    
    <ol>
        <li>The numerical codes are not necessarily portable across platforms.</li>
    </ol>
</blockquote>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em> ... </em></code>: 
zero or more integers.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
a <code>string</code> with length equal to the number of arguments, in 
which each character has the internal numerical code equal to its 
corresponding argument.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).dump" >
<strong>string.dump(f)</strong>
</a>
</dt>
<dd>
	
<p>Returns a <code>string</code> containing a binary representation of the given
<code>function</code>, so that a later <code>loadstring</code> on this <code>string</code> returns a copy of
the <code>function</code>.</p>

	
<p><code>function</code> must be a Lua function without upvalues.</p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em> f </em></code>: 
the <code>function</code> to dump.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
a <code>string</code> representation of the given <code>function</code>.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).find" >
<strong>string.find(s, pattern, init, plain)</strong>
</a>
</dt>
<dd>
	
<p>Looks for the first match of <code>pattern</code> in the <code>string</code> <code>s</code>.</p>

	
<p>If it finds a
match, then <code>find</code> returns the indices of <code>s</code> where this occurrence starts
and ends; otherwise, it returns <code>nil</code>. A third, optional numerical argument
<code>init</code> specifies where to start the search; its default value is <code>1</code> and
can be negative. A value of <code>true</code> as a fourth, optional argument <code>plain</code>
turns off the pattern matching facilities, so the function does a plain
"find substring" operation, with no characters in <code>pattern</code> being considered
"magic". </p>
<h3>Notes:</h3>
<blockquote>
    
    <ol>
        <li>If <code>plain</code> is given, then <code>init</code> must be given as well.</li>
        <li>If the pattern has captures, then in a successful match the captured values
        are also returned, after the two indices.</li>
    </ol>
</blockquote>
<h3>Warnings:</h3>
<blockquote>
    
    <ol>
        <li>Calling <code>string.find</code> on a <code>string</code> returned by <code>string.sub</code> will return the
        index of the character in the original <code>string</code>, not the substring you are
        referencing. </li>
    </ol>
</blockquote>

		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
<code>string</code> to handle.</p>

				</li>
				<li>
				
<p><code><em>#string pattern </em></code>: 
pattern to search. </p>

				</li>
				<li>
				
<p><code><em>#number init </em></code>: 
index where to start the search. (default value is <code>1</code>)</p>

				</li>
				<li>
				
<p><code><em>#boolean plain </em></code>: 
set to <code>true</code> to search without pattern matching. (default value is <code>false</code>)</p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				
<p><em>#number, #number:</em>
start and end indices of first occurence.</p>

				</li>
				<li>
				
<p><em>#nil:</em>
if pattern not found.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).format" >
<strong>string.format(formatstring, ...)</strong>
</a>
</dt>
<dd>
	
<p>Returns a formatted version of its variable number of arguments following
the description given in its first argument (which must be a <code>string</code>).</p>

	
<p>The
format <code>string</code> follows the same rules as the <code>printf</code> family of standard C
functions. The only differences are that the options/modifiers <code>*</code>, <code>l</code>,
<code>L</code>, <code>n</code>, <code>p</code>, and <code>h</code> are not supported and that there is an extra option,
<code>q</code>. The <code>q</code> option formats a <code>string</code> in a form suitable to be safely read
back by the Lua interpreter: the <code>string</code> is written between double quotes,
and all double quotes, newlines, embedded zeros, and backslashes in the
<code>string</code> are correctly escaped when written. For instance, the call</p>

<pre><code>string.format('%q', 'a string with "quotes" and \n new line')
</code></pre>

<p>will produce the string:</p>

<pre><code>"a string with \"quotes\" and \
    new line"
</code></pre>

<p>The options <code>c</code>, <code>d</code>, <code>E</code>, <code>e</code>, <code>f</code>, <code>g</code>, <code>G</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>X</code>, and
<code>x</code> all expect a number as argument, whereas <code>q</code> and <code>s</code> expect a <code>string</code>.
This function does not accept <code>string</code> values containing embedded zeros,
except as arguments to the <code>q</code> option.</p>

		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string formatstring </em></code>: 
the <code>string</code> template. </p>

				</li>
				<li>
				
<p><code><em> ... </em></code>: 
arguments could be <code>strings</code> or <code>numbers</code>.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
the formatted <code>string</code>.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).gmatch" >
<strong>string.gmatch(s, pattern)</strong>
</a>
</dt>
<dd>
	
<p>Returns an iterator function that, each time it is called, returns the
next captures from <code>pattern</code> over <code>string</code> <code>s</code>.</p>

	
<p>If <code>pattern</code> specifies no
captures, then the whole match is produced in each call.
As an example, the following loop</p>

<pre><code>s = "hello world from Lua"
for w in string.gmatch(s, "%a+") do
  print(w)
end
</code></pre>

<p>will iterate over all the words from <code>string</code> <code>s</code>, printing one per line. The
next example collects all pairs <code>key=value</code> from the given <code>string</code> into
a <code>table</code>:</p>

<pre><code>t = {}
s = "from=world, to=Lua"
for k, v in string.gmatch(s, "(%w+)=(%w+)") do
  t[k] = v
end
</code></pre>

<p>For this <code>function</code>, a '<code>^</code>' at the start of a pattern does not work as an
anchor, as this would prevent the iteration.</p>
<h3>Warnings:</h3>
<blockquote>
    
    <ol>
        <li>Using any quantifier other than + will cause it to hang if that
        quantifier applies to the whole pattern and that pattern does not match
        the whole <code>string</code>. </li>
    </ol>
</blockquote>

		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
<code>string</code> to handle.</p>

				</li>
				<li>
				
<p><code><em>#string pattern </em></code>: 
pattern to search.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em><a href="##(func)">#func</a>:</em>
Returns an iterator <code>function</code> that, each time it is called, returns the next captures from pattern over <code>string</code> <code>s</code>.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).gsub" >
<strong>string.gsub(s, pattern, repl, n)</strong>
</a>
</dt>
<dd>
	
<p>Returns a copy of <code>s</code> in which all (or the first <code>n</code>, if given)
occurrences of the <code>pattern</code> have been replaced by a replacement <code>string</code>
specified by <code>repl</code>, which can be a <code>string</code>, a <code>table</code>, or a <code>function</code>.</p>

	
<p><code>gsub</code>
also returns, as its second value, the total number of matches that occurred.</p>

<p>If <code>repl</code> is a <code>string</code>, then its value is used for replacement. The character
<code>%</code> works as an escape character: any sequence in <code>repl</code> of the form <code>%n</code>,
with <em><code>n</code></em> between <code>1</code> and <code>9</code>, stands for the value of the <em><code>n</code></em>-th captured
substring (see below). The sequence <code>%0</code> stands for the whole match. The
sequence <code>%%</code> stands for a single <code>%</code>.</p>

<p>If <code>repl</code> is a <code>table</code>, then the <code>table</code> is queried for every match, using
the first capture as the key; if the pattern specifies no captures, then
the whole match is used as the key.</p>

<p>If <code>repl</code> is a <code>function</code>, then this <code>function</code> is called every time a match
occurs, with all captured substrings passed as arguments, in order; if
the pattern specifies no captures, then the whole match is passed as a
sole argument.</p>

<p>If the value returned by the <code>table</code> query or by the <code>function</code> call is a
<code>string</code> or a <code>number</code>, then it is used as the replacement <code>string</code>; otherwise,
if it is <code>false</code> or <code>nil</code>, then there is no replacement (that is, the original
match is kept in the <code>string</code>).</p>

<p>Here are some examples:</p>

<pre><code>x = string.gsub("hello world", "(%w+)", "%1 %1")
--&gt; x="hello hello world world"
x = string.gsub("hello world", "%w+", "%0 %0", 1)
--&gt; x="hello hello world"
x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
--&gt; x="world hello Lua from"
x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
--&gt; x="home = /home/roberto, user = roberto"
x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
      return loadstring(s)()
    end)
--&gt; x="4+5 = 9"
local t = {name="lua", version="5.1"}
x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
--&gt; x="lua-5.1.tar.gz"
</code></pre>

		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
<code>string</code> to handle.</p>

				</li>
				<li>
				
<p><code><em>#string pattern </em></code>: 
pattern to search. </p>

				</li>
				<li>
				
<p><code><em> repl </em></code>: 
replacement could be a <code>string</code>, a <code>table</code> or a <code>function</code>.</p>

				</li>
				<li>
				
<p><code><em>#number n </em></code>: 
number of occurences to replace, default is <code>nil</code> which means all occurences. </p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
a modified copy of <code>s</code>.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).len" >
<strong>string.len(s)</strong>
</a>
</dt>
<dd>
	
<p>Receives a <code>string</code> and returns its length.</p>

	
<p>The empty <code>string</code> <code>""</code> has
length 0. Embedded zeros are counted, so <code>"a\000bc\000"</code> has length 5.</p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
<code>string</code> to handle.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#number:</em>
the length of <code>s</code>.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).lower" >
<strong>string.lower(s)</strong>
</a>
</dt>
<dd>
	
<p>Receives a <code>string</code> and returns a copy of this <code>string</code> with all uppercase
letters changed to lowercase.</p>

	
<p>All other characters are left unchanged. The
definition of what an uppercase letter is depends on the current locale.</p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
<code>string</code> to handle.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
a lower case version of <code>s</code>.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).match" >
<strong>string.match(s, pattern, init)</strong>
</a>
</dt>
<dd>
	
<p>Looks for the first <em>match</em> of <code>pattern</code> in the <code>string</code> <code>s</code>.</p>

	
<p>If it
finds one, then <code>match</code> returns the captures from the pattern; otherwise
it returns nil. If <code>pattern</code> specifies no captures, then the whole match
is returned. A third, optional numerical argument <code>init</code> specifies where
to start the search; its default value is <code>1</code> and can be negative.</p>

		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
<code>string</code> to handle.</p>

				</li>
				<li>
				
<p><code><em>#string pattern </em></code>: 
pattern to search. </p>

				</li>
				<li>
				
<p><code><em>#number init </em></code>: 
index where to start the search. (default value is <code>1</code>)</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
the captures from the pattern; otherwise it returns <code>nil</code>. If pattern specifies no captures, then the whole match is returned. </p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).rep" >
<strong>string.rep(s, n)</strong>
</a>
</dt>
<dd>
	
<p>Returns a <code>string</code> that is the concatenation of <code>n</code> copies of the <code>string</code> <code>s</code>.</p>

		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
<code>string</code> to handle.</p>

				</li>
				<li>
				
<p><code><em>#number n </em></code>: 
number of repetition.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
the concatenation of <code>n</code> copies of the <code>string</code> <code>s</code>.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).reverse" >
<strong>string.reverse(s)</strong>
</a>
</dt>
<dd>
	
<p>Returns a <code>string</code> that is the <code>string</code> <code>s</code> reversed.</p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
<code>string</code> to handle.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
the <code>string</code> <code>s</code> reversed.</p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).sub" >
<strong>string.sub(s, i, j)</strong>
</a>
</dt>
<dd>
	
<p>Returns the substring of <code>s</code> that starts at <code>i</code> and continues until
<code>j</code>; <code>i</code> and <code>j</code> can be negative.</p>

	
<p>If <code>j</code> is absent, then it is assumed to
be equal to -1 (which is the same as the string length). In particular,
the call <code>string.sub(s,1,j)</code> returns a prefix of <code>s</code> with length <code>j</code>, and
<code>string.sub(s, -i)</code> returns a suffix of <code>s</code> with length <code>i</code>.</p>
<h3>Warnings:</h3>
<blockquote>
    
    <ol>
        <li>Calling <code>string.find</code> on a string returned by <code>string.sub</code> will return the
        index of the character in the original <code>string</code>, not the substring you are
        referencing. </li>
    </ol>
</blockquote>

		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
<code>string</code> to handle.</p>

				</li>
				<li>
				
<p><code><em>#number i </em></code>: 
start index.</p>

				</li>
				<li>
				
<p><code><em>#number j </em></code>: 
end index. (default value is <code>-1</code>, which is the same as the <code>string</code> length)</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
the substring of <code>s</code> that starts at <code>i</code> and continues until <code>j</code>. </p>


</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(string).upper" >
<strong>string.upper(s)</strong>
</a>
</dt>
<dd>
	
<p>Receives a <code>string</code> and returns a copy of this <code>string</code> with all lowercase
letters changed to uppercase.</p>

	
<p>All other characters are left unchanged. The
definition of what a lowercase letter is depends on the current locale.</p>

		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em>#string s </em></code>: 
<code>string</code> to handle.</p>

				</li>
		</ul>
		<h3>Return value</h3>
				
<p><em>#string:</em>
a upper case version of <code>s</code>.</p>


</dd>
</dl>

			<h2><a id="#(Untyped)" >Type <code>Untyped</code></a></h2>
			
			<h2><a id="#(func)" >Type <code>func</code></a></h2>
			
</div>

</div>
</body>
</html>
